The following content is provided under a Creative Commons license. So let's talk a little bit about objects. So how Python represents the object just behind the scenes and what are different ways that you can interact with the object. The number 5 is a different object that's of type integer and so on. We've said that before and in this lecture I think we'll really get at what that means. So we've seen strings, integers, dictionaries, lists. So functions were also objects in Python. So literally everything in Python is an object. And you can create as many objects as you'd like of that particular type, right? So for a list, for example, you can append an item to the end of the list, you can delete an item, remove it, concatenate two lists together. So let's continue exploring what objects are. The interface for the car is what are ways that you can interact with it. Again, we think about it in terms of two things. So behind the scenes how does Python see lists? So what are ways that you can manipulate a list object once it's created? So it's just essentially going to be a chain, going from one index to the other. So these are all ways that you can interact with the list object as soon as you've created it. So just like when we talked about functions, we're going to sort of separate the code that we talk about today into code where you implement a data type and code where you use an object that you create. And attributes are going to be the data representation and ways that you can interact with your object. So let's start defining our own types, OK? So x, y is going to be a coordinate in a 2D plane. Just like we had type list, type string, and so on. This is going to be a type called coordinate. So really, really basic operations that you can do with objects. So inside the class definition we're going to put attributes. Attributes are going to be data and procedures that belong to the class, OK? So the methods are going to define how you can interact with the object. So in a list, for example, we've said that you can append an item to the end of the list, we can sort a list, things like that. And that's going to be a way that you can interact with two coordinate points. Because this distance method was only defined to work with two coordinate type objects. First thing we're going to define are data attributes. In this particular case, we're going to choose to initialize a coordinate object by two values, one for the x and one for the y. And inside this init method, we're going to have two assignments. I'm going to assign it to whatever was passed in. And the y data attribute for a particular object is going to be assigned whatever y was passed in. How do you make sure that x and y are inits or floats? This next line here is origin equals coordinate 0, 0 creates another object. We have to find the init method so we have a way to create objects when we use the class. So pretty much by convention it's always named self. You have DF, some name, it takes in parameters. It does some stuff and then it returns a value. But really all you need to know is what it takes. So when you want to use this method to figure out a distance between two coordinate objects, this is how you do it. First one is named C, the second one is named 0. And I want to first call it on one object, so I'm going to say C dot, so I'm using the dot notation to call the method distance on object C. So Python says this object C is of type coordinate. An easier way to see what happens is by looking at what this line here is equivalent to. So when you create a list, you say L is equal to 1, 2, and then you say L.append, you know, 3 or whatever. Maybe you wanted to know what the values for x and y were. So what you need to do is you need to define your own method that tells Python what to do when you call print on an object of this type. So this is going to be a special method, just like init is, because it starts and ends with double underscores. So underscore, underscore, str, underscore, underscore, is a method. Let's create a coordinate object, assign it 3, 4, as we have been, and assign it to variable C. We've implemented the str method, so when we print C, it's going to print out this nice three comma for our angle brackets. And you tell it how to do that by implementing this special method. So if you want to figure out whether two objects are equal. So we've looked at coordinate, we saw sort of a higher level car object. And I've decided that I will not let them be floats. Since I plan on debugging this code maybe possibly sometime in the future, I'm also including an str method and the str method is going to print a nice looking string that's going to represent the numerator, and then a slash, and then the denominator. And how do I convert a fraction to a float? So as it's the same type of object, then on the return value I can do all of the exact same operations that I can do on a regular fraction object. This is going to be 1 over 4 for a. And b is going to be 3 over four. It is and it's just going to do whatever's inside here. It's going to calculate the top and the bottom. Notice I'm doing the exact same method call, except I'm doing it the other way where you type in the name of the class, name of the method, and then what you're calling it on, and this gives the exact same value here, 1.0. So take a look at this code in more detail and see if you can trace through all of those different things and see if you can also write your own new fraction objects. And all of these objects are going to have the same data representation and the same methods that you can do on them.