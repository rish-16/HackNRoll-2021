The following content isnprovided under a CreativeCommons license. Behind the scenes,nthough, every objecthas these two additional things. So how Python represents thenobject just behind the scenesand what are differentnways that youcan interact with the object. So for example, every one ofnthese is a different object. The number 5 is a differentnobject that's of type integerand so on. Lists and dictionaries arenmore complicated objects. We've said that beforenand in this lectureI think we'll reallynget at what that means. So we've seen strings,nintegers, dictionaries, lists. When we did functions,nwe saw that wecould pass as a parameternanother function. So functions were alsonobjects in Python. So literally everythingnin Python is an object. And you can createnas many objectsas you'd like of thatnparticular type, right?An integer 5 and integer 7.Those all work in a program. Once you've creatednthese new objects,you can manipulate them. So that's ways that youncan interact with objects. And the last thing you canndo is you can destroy them. So let's continuenexploring what objects are. The first is some sortnof representation. So for example, youncould paint a car, right?So you could change its color. You could have thencar make a noiseand different cars mightnmake different noises. Or you can drive the car, right?So these are all ways thatnyou can interact with the car. Whereas the representationnare what makes up the car. Let's bring it a little closernto home by looking at a list. So we have this datantype of list, right?We've worked with lists before. The list with elements 1, 2, 3,nand 4 is a very specific objectthat is of type list. Again, we think about itnin terms of two things. One is what is the datanrepresentation of the list?So behind the scenes howndoes Python see lists?And the second is, how donyou interact with lists?So what are ways thatnyou can manipulate a listobject once it's created?So behind the scenesnyou have a list, L,which is going to be made upnof essentially two things. One is going to be thenvalue at specific index. And in index 2 younhave the value and thenthe next pointer,nand so on and so on. You also weren't aware of hownthese lists were representedinternally. You, as someone whonuses this class,doesn't really need to knownhow a list is representedinternally in ordernto be able to use itand to write coolnprograms with them. So you, as thenprogrammer of this class,are going to decidenhow you want peopleto interact with the objectnand what data this objectis going to have. So for example,nsomeone wrote codethat implements anlist class, right,and we don't actuallynknow how that was done. So creating the class isnimplementing the classand figuring out datanrepresentation and waysto interact with the class. And you can create as manynobjects as you'd like. And a coordinatenobject is essentiallygoing to be an objectnthat's going to definea point in an xy plane. So x, y is going to be ancoordinate in a 2D plane. So the way we do that isnwe have to define a class. Just like we had type list,ntype string, and so on. This is going to be antype called coordinate. And then innparentheses here, youput what the parentsnof the class are. For today's lecture, thenparent of the classesare going to be thisnthing called object,and object is the verynbasic type in Python. So really, reallynbasic operationsthat you can do with objects. So inside the class definitionnwe're going to put attributes. OK.If you try to use any ofnthe data or the procedureswith an object ofna different type,you're going to get annerror because these dataand these attributes willnbelong to this particular class. And procedure attributesnare better known as methods. And you can think of anmethod as a function. So the methods arengoing to define how youcan interact with the object. Because this distance method wasnonly defined to work with twocoordinate type objects. First thing we're going tondefine are data attributes. So how do we do that?So let's implement it. And we give it somenparameters, right,just like any other function. The self, however, isna little bit trickier. So the self is goingnto be a parameter whenyou define thisnclass that representsa particular instancenof the class. OK.In this particularncase, we're goingto choose to initializena coordinate objectby two values, one fornthe x and one for the y. The first one says,nthe x data attributeof a coordinate object. I'm going to assign it tonwhatever was passed in. And we're going tonsee in class exercisethat you can havenit be different. So this defines the waynthat we create an object. It's going to call the initnmethod with x is equal to 3and y is equal to 4.I'm just going to go over herenand I wrote this previously,because notice when we'rencreating an object here,we're only givingnit two parameters. And that's OK becausenimplicitly, Pythonis going to say self is goingnto be this object C, so justby default, OK?So when you're creatingna coordinate object,you're passing it all thenvariables except for self. This next line here isnorigin equals coordinate 0,0 creates another object. OK?It's another coordinatenobject whose value for x is 0and whose value for y is 0.So now we have twoncoordinate objects. So the same dot notation cannbe used with your own objectsin order to accessndata attributes. So let's go back to definingnour coordinate classand let's definena method for it. So so far we've definednthat part there,class coordinate and an init. So in this slide we're goingnto add this method here. So this method herenis going to sayI'm going to define anmethod called distanceand I'm going to passnin two parameters. So pretty much by conventionnit's always named self. And this is going to representnthe other coordinate objectfor which I want to findnthe distance from my self. If I just did x, I would benaccessing just some variablenamed x in a program whichnactually isn't even defined. It does some stuff andnthen it returns a value. So you have to use thendot notation in orderto decide whose datanattributes you want access. So we've defined thenmethod here, distance. But really all you neednto know is what it takes. So when you wantnto use this methodto figure out a distancenbetween two coordinate objects,this is how you do it. Second line, I createnanother coordinate object. First one is named C, thensecond one is named 0.These are two separate objects. An easier way tonsee what happensis by looking at what thisnline here is equivalent to. And as I mentioned,nPython implicitly says,if you're doing thenone on the left,you can call this methodnon a particular objectand it's going to looknup the type of the objectand it's going to essentiallynconvert this on the leftto the one on the right. And this is what you'venbeen using so far. So when you create a list,nyou say L is equal to 1, 2,and then you say L.append,nyou know, 3 or whatever. If you print C, younget this funny message. Which is not what younwanted at all, right?Maybe you wanted to know whatnthe values for x and y were. And if you define this method innyour class, that tells Python,hey, when you see anprint statement that'son an object of typencoordinate, call this method,look what it does, and doneverything that's inside it. And you can choose to makenit do whatever you wantinside your definition of str. That seems reasonable, right?So then from now on when younprint coordinate objects,you're going to seenthings like this, whichis a lot more informative. So we define the initnand the distance,and let's define this str. So underscore, underscore,nstr, underscore, underscore, isa method. Let's create ancoordinate object,assign it 3, 4, as we have been,nand assign it to variable C.We've implemented the strnmethod, so when we print C,it's going to print out thisnnice three comma for our anglebrackets. So you're definingnthe type of an object. Couple more words onnthese special operators. So these specialnoperators allow youto customize your classes whichncan add some cool functionalityto them. So these specialnoperators are goingto be things likenaddition, subtraction,using the equal equal sign,ngreater than, less than,length and so on and so on. And you tell it how tondo that by implementingthis special method. So if you want to figure outnwhether two objects are equal. And when you implement thesenmethods in your own class,you can decide exactlynwhat you want to do. And then you documentnwhat you've decided. OK.So that's going tonbe a fraction object. So the way I've decided toninternally represent a fractionobject is with two numbers. They have to be integers,nhence the assert over here. So inside the init,nI've decided I'mgoing to represent mynfracture with two numbers, onefor the numerator andnone for the denominator. And a particularninstance is goingto have self dotnnumerator and self dotdenominator as itsndata attributesand I'm assigning those to benwhatever's passed into my init. And then I've also implementednsome other special methods. How do we add two fractions?We're going to take self, whichnis the instance of an objectthat I want to donthe add operation on,and we're going tontake other, whichis the otherninstance of an objectthat I want to do thenoperation on, so the addition,and I'm going tonfigure out the new top. So the new top of thenresulting fraction. So that's why I havento use self dot here. And then I'm defining herenmy own method called inverse. And this is just going to takenthe inverse of the instance I'mcalling this method on. So that's how I implementnmy fraction object. So now let's use it andnsee what it gives us. It's going to calculatenthe top and the bottom. Notice I'm doing thenexact same method call,except I'm doing itnthe other way whereyou type in the name of thenclass, name of the method,and then what you'rencalling it on,and this gives the exactnsame value here, 1.0.And then here I'm callingnthe method inverseon object B which is going toninvert 3 over 4 to be 4 over 3.And then I'm convertingnit to a floatand then I'm printing the value. Power of objectnoriented programmingis that you can bundlentogether objects thatare of the exact same type.