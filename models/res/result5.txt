The following content is provided under a CreativeCommons license. And if you haven't programmed before,I think this is a fairly tough concept to grasp. So let's talk a little bit about objects. So every object that we've seen has a certain type. Behind the scenes, though, every objecthas these two additional things. So how Python represents the object just behind the scenesand what are different ways that youcan interact with the object. So for example, every one of these is a different object. The number 5 is a different object that's of type integerand so on. Lists and dictionaries are more complicated objects. We've said that before and in this lectureI think we'll really get at what that means. So we've seen strings, integers, dictionaries, lists. When we did functions, we saw that wecould pass as a parameter another function. So functions were also objects in Python. So literally everything in Python is an object. Once you've created these new objects,you can manipulate them. So that's ways that you can interact with objects. So let's continue exploring what objects are. So let's say I have these two separate objects. The first is some sort of representation. Or you can drive the car, right?So these are all ways that you can interact with the car. Whereas the representation are what makes up the car. Let's bring it a little closer to home by looking at a list. And internally this pointer is goingto tell Python where is the memorylocation in the computer where you can access the elementindex 1.So it's just essentially going to be a chain,going from one index to the other. So this is how Python internally represents a list. OK?How you manipulate lists, we've done this a lot, right?You can index into a list, you can add two lists together,you can get the length, you can append to the end of a list,you can sort a list, reverse a list, and so many other things,right?So these are all ways that you caninteract with the list object as soon as you've created it. You also weren't aware of how these lists were representedinternally. You, as someone who uses this class,doesn't really need to know how a list is representedinternally in order to be able to use itand to write cool programs with them. OK.So just like when we talked about functions,we're going to sort of separate the codethat we talk about today into code where you implement a datatype and code where you use an object that you create. So creating the class is implementing the classand figuring out data representation and waysto interact with the class. And you use the class by creatingnew instances of the class. And you can create as many objects as you'd like. You can do all the operations that you'vedefined on the class. And a coordinate object is essentiallygoing to be an object that's going to definea point in an xy plane. So x, y is going to be a coordinate in a 2D plane. So the way we do that is we have to define a class. In this case, we're creating a type called coordinate. Just like we had type list, type string, and so on. This is going to be a type called coordinate. And then in parentheses here, youput what the parents of the class are. So really, really basic operationsthat you can do with objects. So we've told Python we wanted to define an object. So inside the class definition we're going to put attributes. And procedure attributes are better known as methods. And you can think of a method as a function. So the methods are going to define how youcan interact with the object. OK?And that's going to be a way that you can interactwith two coordinate points. All right, so let's carry on and continueimplementing our class. So we've written this first line so far,class coordinate object. First thing we're going to define are data attributes. So how do we do that?So let's implement it. The self, however, is a little bit trickier. So we're defining this coordinate objectin sort of a general way, right?We don't have a specific instanceyet because we haven't created an object yet. But this self is going to be sortof a placeholder for any sort of instancewhen you create the object. So in the definition of the class,whenever you want to refer to attributesthat belong to an instance, you have to use self dot. And the dot is going to say look for a data attributex that belongs to this class. OK.In this particular case, we're goingto choose to initialize a coordinate objectby two values, one for the x and one for the y. I'm going to assign it to whatever was passed in. Questions so far about how to write this init?Yeah, question. Does the x, does this self x and this xhave to be the same name. And we're going to see in class exercisethat you can have it be different. So this defines the way that we create an object. This next line here is origin equals coordinate 0,0 creates another object. OK?It's another coordinate object whose value for x is 0and whose value for y is 0.So now we have two coordinate objects. So the same dot notation can be used with your own objectsin order to access data attributes. But that's kind of lame, right, because there isn't anythingcool we can do with it. So let's go back to defining our coordinate classand let's define a method for it. So this method here is going to sayI'm going to define a method called distanceand I'm going to pass in two parameters. So pretty much by convention it's always named self. And then for this particular method,I'm going to give it another parameter,and I can name this whatever I want. So notice this method is pretty much like a function, right?You have DF, some name, it takes in parameters. It does some stuff and then it returns a value. So we've defined the method here, distance. Now how do we use it?So let's assume that the definition of distanceis up here. But really all you need to know is what it takes. So when you want to use this methodto figure out a distance between two coordinate objects,this is how you do it. So the first line, I create one coordinate object. Second line, I create another coordinate object. It's going to look up at the classcoordinate that you defined. An easier way to see what happensis by looking at what this line here is equivalent to. And this is what you've been using so far. If you print C, you get this funny message. Which is not what you wanted at all, right?Maybe you wanted to know what the values for x and y were. So what you need to do is you needto define your own method that tellsPython what to do when you call printon an object of this type. And if you define this method in your class, that tells Python,hey, when you see a print statement that'son an object of type coordinate, call this method,look what it does, and do everything that's inside it. And you can choose to make it do whatever you wantinside your definition of str. So underscore, underscore, str, underscore, underscore, isa method. Any questions?OK.So let's try to wrap our head around types and classesbecause we've seen a lot today. Let's create a coordinate object,assign it 3, 4, as we have been, and assign it to variable C.We've implemented the str method, so when we print C,it's going to print out this nice three comma for our anglebrackets. So you're defining the type of an object. So these special operators allow youto customize your classes which can add some cool functionalityto them. If you have not implemented this methodand you try to add two objects of type coordinate,you're going to get an error because Python doesn't actuallyknow right off the bat how to addtwo coordinate objects, right?You have to tell it how to do that. And you tell it how to do that by implementingthis special method. So if you want to figure out whether two objects are equal. And when you implement these methods in your own class,you can decide exactly what you want to do. And then you document what you've decided. So we've looked at coordinate, wesaw sort of a higher level car object. Fraction object is going to be, isgoing represent a number that's going to be a numerator slashdenominator. So the way I've decided to internally represent a fractionobject is with two numbers. They have to be integers, hence the assert over here. And a particular instance is goingto have self dot numerator and self dotdenominator as its data attributesand I'm assigning those to be whatever's passed into my init. And then I've also implemented some other special methods. So the new top of the resulting fraction. So the top is going to be that, the bottom is going to be that. So that's why I have to use self dot here. It's not a number, it's not a float, it's not an integer. So as it's the same type of object,then on the return value I can doall of the exact same operations that I can doon a regular fraction object. And then I'm defining here my own method called inverse. So now let's use it and see what it gives us. A is equal to a fraction 1, 4.This is going to be 1 over 4 for a. So this is going to be 4 plus 12 divided by 16, and 16 over 16.So C as a fraction object is goingto be 16 for the numerator and 16 for the denominatorbecause it's a fraction object. Notice I'm doing the exact same method call,except I'm doing it the other way whereyou type in the name of the class, name of the method,and then what you're calling it on,and this gives the exact same value here, 1.0.And then here I'm calling the method inverseon object B which is going to invert 3 over 4 to be 4 over 3.And then I'm converting it to a floatand then I'm printing the value. Power of object oriented programmingis that you can bundle together objects thatare of the exact same type. And all of these objects are goingto have the same data representationand the same methods that you can do on them.